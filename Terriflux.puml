@startuml Terriflux
!theme reddress-darkgreen

mainframe Terriflux

/' MAIN SCENE '/
class MainScene 
{
    + {override} _Ready()
    + {override} _Process()
}
MainScene *--> IImpacts : - impacts
MainScene *--> IGrid : - grid
MainScene *--> IInventory : - inventory
MainScene ..> BuildingFactory : use  /' Via la PlacementList '/
MainScene ..> IAlert : use  

/' GENERAL '/
/' Any node of our own creation '/
abstract RawNode  /' extends Godot.Node '/
{
    # {readonly} PATH_NODES : string = "Nodes/"
    # {readonly} PATH_PROGRAMS : string = "Programs/"
    # {readonly} PATH_IMAGES : string = "Ressources/Images/"
    # RawNode() /' this.Name = this.getClass().ToString() '/ 
    + {override} _Ready()
    + ^Verbose()
}

/' CELLS '/
interface ICell 
{
    + GetDimensions() : VectorI 
    + IsSelected() : Boolean
    + Select()
    + Unselect() /' TODO - actuel ResetTexture '/
}
abstract Cell extends RawNode implements ICell
{
    - {static} {readonly} DEFAULT_TEXTURE : Texture2D
    - {static} {readonly} SIZE : Vector2I 
    - {readonly} selfTexture : Texture2D
    # Cell()
    # ChangeSkin(texture : Texture2D)
    + ^{override} _Ready() /' ChangeSkin() '/
    + ^GetDimensions() : Integer[2] 
    + ^IsSelected() : Boolean
    + ^Select()
    + ^Unselect() 
    + ^{override} Verbose()
    - OnMouseAbove()
    - OnMouseOutside()
    - OnPressed()
}
class Grass extends Cell
{
    + Grass() 
}
abstract Building extends Cell
{
    - {readonly} impacts : Real[3]
    + Building(impacts : Real[3], needs : FlowKind[*], minimalProduction : FlowKind[*], texture : Texture2D, colorOfDot : Color)
    + GetImpacts() : Real[3]
    + GetNeeds() : FlowKind[*]
    + GetProduction() : FlowKind[*]     /' minimal product '/
    + GetNeedOf(flow : FlowKind) : Integer
    + GetProductOf(flow : FlowKind) : Integer        /' minimal product '/
    + IsActive() : Boolean /' will produce sth this turn '/
    + ^{override} Verbose()
}
/' needs & minimalProduction = (FlowKind, Integer)[*] '/
Building" * " o--> " * "FlowKind : - {readonly} needs \n needs      
Building" * " o--> " * "FlowKind : - {readonly} minimalProduction \n products
enum FlowKind
{
    WATER
    ENERGY
    CEREALS
    BREAD
    RAW_MATERIAL
    MANUFACTURED_MERCHANDISE
}
class Field extends Building
{
    + Field()       /' 1.5, 4.0, -2.0; WATER,1 ; CEREALS,2 ; #Ce517b '/
}
class Factory extends Building
{
    + Factory()    /' 8.5, -23.0, -11.8 ; WATER,3, ENERGY,7, RAW_MATERIAL,4 ; MANUFACTURED_MERCHANDISE,5 ; #Ce7651 '/
}
class Bakery extends Building
{
    + Bakery()      /' 3.0, -1.0, -4.0 ; WATER,2, ENERGY,1, CEREALS,2 ; BREAD,3 ; #Ceb851 '/
}
class Supplier extends Building
{
    + Supplier()        /' 2.5, -2.0, -5.0 ; ; WATER,5, ENERGY,6 ; #51ce60 '/
}
class Grocery extends Building
{
    + Grocery()         /' 15.0, -2.5, -2.5 ; MANUFACTURED_MERCHANDISE,3, ENERGY,1 ; #51ceb4 '/
}
class BuildingFactory
{
    + BuildingFactory()
    + createField()
    + createFactory()
    + createBakery()
    + createSupplier()
    + createGrocery()
}

/' ROUNDS '/
interface IRound
{
    + GetNumber() : Integer
    + Next()
}
class Round extends RawNode implements IRound
{
    + GetNumber() : Integer
    + Next()
}

/' GRID '/
interface IGrid
{
    + GetSize() : Vector2I
    + GetAll() : ICell[*]       /' (ICell, Vector2I)[*] '/
    + GetAt(coordinates : Vector2I) : ICell
    + SetAt(coordinates : Vector2I, cell : ICell)
    + DistanceBewteen(position1 : Integer[2], position2 : Integer[2]) : Integer
    + GetInactiveCells() : ICell[*]        /' notamment les batiments qui ne peuvent produire '/
}
IGrid" * " *--> " * "ICell : - cells[*,*] 
/' gere uniquement le placement de cellule (et donc batiments) 
et les operations qui le precedent/suivent (choix du type, des coordonnees, etc) '/
interface ICellUsher  
{
    + SetWantedCell(cell : ICell)
    + SetWantedCoordinates(coordinates : Vector2I)
    + GetMaxPlacementPerTurn() : Integer
    + GetPlacedThisTurn() : Integer
    + GetMaluses() : double[3] 
    + NextTurn()
    + Place()   /' Confirm the placement - old StartPlacement() '/
}
ICellUsher" * " *--> " 1 "ICell : - wantedModel 
ICellUsher" * " *--> " 1 "IImpacts : - impacts 
ICellUsher" * " *--> " 1 "IRound : - round 
class Grid extends RawNode implements IGrid, ICellUsher
{
    - size : Vector2I
    - maxPerTurn : Integer
    - buildedThisTurn : Integer
    - wantedCoordinates : Vector2I
    + {static} NewWasteland(size : Integer)
    + Grid(impacts : impacts, round : IRound)
    + ^SetWantedCell(cell : ICell)
    + ^SetWantedCoordinates(coordinates : Vector2I)
    + ^GetMaxPlacementPerTurn() : Integer
    + ^GetPlacedThisTurn() : Integer
    + ^Place()
    + ^GetSize() : Vector2I
    + ^GetAll() : ICell[*]       
    + ^GetAt(coordinates : Vector2I) : ICell
    + ^SetAt(coordinates : Vector2I, cell : ICell)
    + ^DistanceBewteen(position1 : Integer[2], position2 : Integer[2]) : Integer[2]
    + ^GetInactiveCells() : ICell      
    + ^GetMaluses() : double[3]      
    + GetInactiveAlert() : string
}

/' INVENTORY & IMPACTS '/
interface IGauge
{
    + Increments(add : Real)
    + Get() : Real
}
abstract Gauge implements IGauge
{
    # Gauge()
    + ^Increments(add : Real)
    + ^Get() : Real
}
class EcologyGauge extends Gauge
{
    + EcologyGauge()
}
class EconomyGauge extends Gauge
{
    + EconomyGauge()
}
class SociabilityGauge extends Gauge
{
    + SociabilityGauge()
}
interface IImpacts
{
    + IncrementsEcology(add : Real)
    + IncrementsEconomy(add : Real)
    + IncrementsSocial(add : Real)
    + GetEcology() : Real
    + GetEconomy() : Real
    + GetSocial() : Real
}
IImpacts" 1 " *--> " 3 "IGauge : - gauges
interface IInventory 
{
    + Add(flow : FlowKind, amount : Integer)
    + Remove(flow : FlowKind, amount : Integer)
    + Contains(flow : FlowKind) : Boolean
    + GetQuantityOf(flow : FlowKind) : Integer
}
class Inventory extends RawNode implements IImpacts, IInventory /' ancien node Impact avec acces inventaire ET jauges, mais renomm√© '/
{   
    + ^IncrementsEcology(add : Real)
    + ^IncrementsEconomy(add : Real)
    + ^IncrementsSocial(add : Real)
    + ^GetEcology() : Real
    + ^GetEconomy() : Real
    + ^GetSocial() : Real
    + ^Add(flow : FlowKind, amount : Integer)
    + ^Remove(flow : FlowKind, amount : Integer)
    + ^Contains(flow : FlowKind) : Boolean
    + ^GetQuantityOf(flow : FlowKind) : Integer
    + {override} ^Verbose() : string
    - ContainsEnough(flow : FlowKind, amount : Integer) : Boolean
}

/' MESSAGE to user '/
interface IAlert
{
    + Say(text : string)
    + Close()
}
class Alert implements IAlert
{
    + ^Say(text : string)
    + ^Close()
}

@enduml